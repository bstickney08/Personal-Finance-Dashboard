# A simple, self-contained Python script to perform the required financial analysis.
# This script simulates the backend logic and prepares data for the frontend.
# NOTE: This script must be run *after* Partner 1's script to ensure 'clean_expenses.csv' exists.

import pandas as pd
import numpy as np
import json
import warnings
from statsmodels.tsa.api import ExponentialSmoothing

# Suppress minor future warnings for cleaner output
warnings.simplefilter(action='ignore', category=FutureWarning)

# --- 1. Data Setup (Reads Cleaned Data from Partner 1) ---
def load_cleaned_expense_data(file_path="clean_expenses.csv"):
    """
    Reads the cleaned expense data CSV generated by Partner 1.
    
    Filters for 'expense' transactions and converts columns for time series analysis.
    """
    try:
        # Load the CSV file created by Partner 1
        df = pd.read_csv(file_path)

        # Filter to only include 'expense' type transactions
        df = df[df["type"].str.lower() == "expense"].copy()
        
        # Ensure the date column is a datetime object
        df["date"] = pd.to_datetime(df["date"])
        
        # Set 'date' as the index for time series analysis
        df = df.set_index("date").sort_index()
        
        # Rename columns to match what the rest of the script expects (amount and category)
        return df[['clean_amount', 'auto_category']].rename(columns={'clean_amount': 'amount', 'auto_category': 'category'})
        
    except FileNotFoundError:
        print(f"Error: Required file '{file_path}' not found. Ensure Partner 1's script has run successfully.")
        return pd.DataFrame() # Return empty DataFrame on failure


# --- 2. Calculation Functions (Unchanged from original script) ---

def calculate_performance_metrics(monthly_series):
    """Calculates the latest Month-over-Month (MoM) change."""
    
    # Ensure there are at least two months of data for MoM comparison
    if monthly_series.shape[0] < 2:
        return {'latest_monthly_change_percent': 0.0}

    latest_month = monthly_series.iloc[-1]
    previous_month = monthly_series.iloc[-2]

    # Handle division by zero if the previous month had zero spending
    if previous_month == 0:
        change_percent = 0.0
    else:
        change_percent = ((latest_month - previous_month) / previous_month) * 100
        
    return {
        'latest_monthly_change_percent': round(change_percent, 2)
    }

def calculate_forecast(monthly_series, months=3):
    """Uses Exponential Smoothing to forecast future spending."""
    
    if monthly_series.shape[0] < 12:
        # Not enough data for a reliable forecast
        return {'forecast_available': False, 'forecast_values': []}

    try:
        # Fit the model: Additive seasonal smoothing (common for monthly data)
        model = ExponentialSmoothing(
            monthly_series, 
            seasonal_periods=12, # Assume a 12-month seasonality pattern
            trend='add', 
            seasonal='add'
        ).fit()
        
        # Forecast 'months' periods ahead
        forecast = model.forecast(months)
        
        # Prepare data for frontend visualization
        forecast_values = []
        last_date = monthly_series.index[-1]
        
        for i in range(months):
            # Calculate the date for the forecasted month
            forecast_date = last_date + pd.DateOffset(months=i + 1)
            forecast_values.append({
                'date': forecast_date.strftime('%Y-%m'),
                'forecasted_amount': round(max(0, forecast.iloc[i]), 2) # Spending shouldn't be negative
            })
            
        return {'forecast_available': True, 'forecast_values': forecast_values}
        
    except Exception as e:
        # This handles cases where the model fails to converge
        print(f"DEBUG: Forecasting failed: {e}")
        return {'forecast_available': False, 'forecast_values': []}


# --- 3. Main Execution Block ---

def run_analysis():
    """Runs all analyses and formats output as JSON for the frontend."""
    # Debug print statement to confirm execution start
    print("DEBUG: Starting analysis...")
    
    # Load cleaned data
    df = load_cleaned_expense_data() 
    
    if df.empty:
        print("DEBUG: Analysis stopped because data frame is empty.")
        return # Exits the function if no data

    try:
        # 1. Total Spending
        total_spending = df['amount'].sum()

        # 2. Category Breakdown (for Pie Chart)
        category_breakdown = df.groupby('category')['amount'].sum().sort_values(ascending=False).round(2)

        # 3. Monthly Time Series (for Forecasting)
        monthly_series = df['amount'].resample('M').sum()
        
        # 4. Performance Metrics (MoM Change)
        performance_metrics = calculate_performance_metrics(monthly_series)

        # 5. Forecasting (3 months ahead)
        forecast_data = calculate_forecast(monthly_series, months=3)
        
        # 6. Extract Next Month Forecast
        next_month_forecast = forecast_data['forecast_values'][0]['forecasted_amount'] if forecast_data['forecast_available'] and forecast_data['forecast_values'] else 0.0
        
        # 7. Prepare Historical Monthly Data for Visualization
        monthly_history_list = monthly_series.rename('amount').reset_index()
        monthly_history_list['date'] = monthly_history_list['date'].dt.strftime('%Y-%m')

        results = {
            'summary_metrics': {
                'total_spending': round(total_spending, 2), 
                'latest_monthly_change_percent': performance_metrics['latest_monthly_change_percent'],
                'next_month_forecasted_spending': round(next_month_forecast, 2),
            },
            'visualization_data': {
                'category_totals': category_breakdown.to_dict(), 
                'monthly_history': monthly_history_list.to_dict(orient='records'), 
                'forecast': forecast_data['forecast_values']
            },
            'metadata': {
                'analysis_time': pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S'),
            }
        }
        
        # Output the JSON object (This is the final deliverable for the frontend)
        print(json.dumps(results, indent=4))
        
    except Exception as e:
        # This ensures any hidden error prints to the terminal
        print(f"AN UNCAUGHT ERROR OCCURRED during analysis: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    run_analysis()
